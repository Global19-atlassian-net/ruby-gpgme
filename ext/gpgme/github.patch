diff --git a/src/posix-io.c b/src/posix-io.c
index a351806f..4a41560c 100644
--- a/src/posix-io.c
+++ b/src/posix-io.c
@@ -31,6 +31,7 @@
 #include <errno.h>
 #include <signal.h>
 #include <fcntl.h>
+#include <poll.h>
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
@@ -59,7 +60,9 @@
 #include "ath.h"
 #include "debug.h"
 
-
+#define POLLFD_MAX 65536
+
+
 void
 _gpgme_io_subsystem_init (void)
 {
@@ -143,6 +146,7 @@ _gpgme_io_pipe (int filedes[2], int inherit_idx)
 {
   int saved_errno;
   int err;
+  int oldflags;
   TRACE_BEG2 (DEBUG_SYSIO, "_gpgme_io_pipe", filedes,
 	      "inherit_idx=%i (GPGME uses it for %s)",
 	      inherit_idx, inherit_idx ? "reading" : "writing");
@@ -151,8 +155,8 @@ _gpgme_io_pipe (int filedes[2], int inherit_idx)
   if (err < 0)
     return TRACE_SYSRES (err);
 
-  /* FIXME: Should get the old flags first.  */
-  err = fcntl (filedes[1 - inherit_idx], F_SETFD, FD_CLOEXEC);
+  oldflags = fcntl (filedes[1 - inherit_idx], F_GETFD, 0);
+  err = fcntl (filedes[1 - inherit_idx], F_SETFD, oldflags | FD_CLOEXEC);
   saved_errno = errno;
   if (err < 0)
     {
@@ -282,51 +286,11 @@ _gpgme_io_set_nonblocking (int fd)
 static long int
 get_max_fds (void)
 {
-  const char *source = NULL;
+  char *source = NULL;
   long int fds = -1;
   int rc;
 
-  /* Under Linux we can figure out the highest used file descriptor by
-   * reading /proc/self/fd.  This is in the common cases much faster
-   * than for example doing 4096 close calls where almost all of them
-   * will fail.
-   *
-   * Unfortunately we can't call opendir between fork and exec in a
-   * multi-threaded process because opendir uses malloc and thus a
-   * mutex which may deadlock with a malloc in another thread.  Thus
-   * the code is not used until we can have a opendir variant which
-   * does not use malloc.  */
-/* #ifdef __linux__ */
-/*   { */
-/*     DIR *dir = NULL; */
-/*     struct dirent *dir_entry; */
-/*     const char *s; */
-/*     int x; */
-
-/*     dir = opendir ("/proc/self/fd"); */
-/*     if (dir) */
-/*       { */
-/*         while ((dir_entry = readdir (dir))) */
-/*           { */
-/*             s = dir_entry->d_name; */
-/*             if ( *s < '0' || *s > '9') */
-/*               continue; */
-/*             x = atoi (s); */
-/*             if (x > fds) */
-/*               fds = x; */
-/*           } */
-/*         closedir (dir); */
-/*       } */
-/*     if (fds != -1) */
-/*       { */
-/*         fds++; */
-/*         source = "/proc"; */
-/*       } */
-/*     } */
-/* #endif /\* __linux__ *\/ */
-
 #ifdef RLIMIT_NOFILE
-  if (fds == -1)
     {
       struct rlimit rl;
       rc = getrlimit (RLIMIT_NOFILE, &rl);
@@ -380,16 +344,6 @@ get_max_fds (void)
       fds = 1024;
     }
 
-  /* AIX returns INT32_MAX instead of a proper value.  We assume that
-   * this is always an error and use a more reasonable limit.  */
-#ifdef INT32_MAX
-  if (fds == INT32_MAX)
-    {
-      source = "aix-fix";
-      fds = 1024;
-    }
-#endif
-
   TRACE2 (DEBUG_SYSIO, "gpgme:max_fds", 0, "max fds=%i (%s)", fds, source);
   return fds;
 }
@@ -433,8 +387,11 @@ _gpgme_io_spawn (const char *path, char *const argv[], unsigned int flags,
 {
   pid_t pid;
   int i;
+  int start;
   int status;
   int signo;
+  int oldflags;
+  struct pollfd pfd[POLLFD_MAX];
 
   TRACE_BEG1 (DEBUG_SYSIO, "_gpgme_io_spawn", path,
 	      "path=%s", path);
@@ -459,9 +416,10 @@ _gpgme_io_spawn (const char *path, char *const argv[], unsigned int flags,
       /* Intermediate child to prevent zombie processes.  */
       if ((pid = fork ()) == 0)
 	{
-	  /* Child.  */
-          int max_fds = -1;
+          int max_fds = get_max_fds();
           int fd;
+
+	  /* Child.  */
 	  int seen_stdin = 0;
 	  int seen_stdout = 0;
 	  int seen_stderr = 0;
@@ -469,40 +427,40 @@ _gpgme_io_spawn (const char *path, char *const argv[], unsigned int flags,
 	  if (atfork)
 	    atfork (atforkvalue, 0);
 
-          /* First close all fds which will not be inherited.  If we
-           * have closefrom(2) we first figure out the highest fd we
-           * do not want to close, then call closefrom, and on success
-           * use the regular code to close all fds up to the start
-           * point of closefrom.  Note that Solaris' closefrom does
-           * not return errors.  */
-#ifdef HAVE_CLOSEFROM
-          {
-            fd = -1;
-            for (i = 0; fd_list[i].fd != -1; i++)
-              if (fd_list[i].fd > fd)
-                fd = fd_list[i].fd;
-            fd++;
-#ifdef __sun
-            closefrom (fd);
-            max_fds = fd;
-#else /*!__sun */
-            while ((i = closefrom (fd)) && errno == EINTR)
-              ;
-            if (!i || errno == EBADF)
-              max_fds = fd;
-#endif /*!__sun*/
-          }
-#endif /*HAVE_CLOSEFROM*/
-          if (max_fds == -1)
-            max_fds = get_max_fds ();
-          for (fd = 0; fd < max_fds; fd++)
-            {
-              for (i = 0; fd_list[i].fd != -1; i++)
-                if (fd_list[i].fd == fd)
-                  break;
-              if (fd_list[i].fd == -1)
-                close (fd);
-            }
+          /* First close all fds which will not be inherited. */
+	  for (start = 0; start < max_fds; start += POLLFD_MAX)
+	    {
+	      int nonzero;
+	      for (fd = start; fd < start + POLLFD_MAX; fd++)
+		{
+		  struct pollfd *p = &pfd[fd - start];
+		  p->fd = (fd < max_fds) ? fd : -1;
+		  p->events = 0;
+		}
+	      do
+	        {
+		  nonzero = poll (pfd, max_fds < POLLFD_MAX ? max_fds : POLLFD_MAX, 0);
+		}
+	      while (nonzero <= 0 && (errno == EINTR || errno == EAGAIN));
+	      if (nonzero <= 0)
+		{
+		  TRACE_LOG1 ("poll failed in child: %s\n",
+			      strerror (errno));
+		  _exit(8);
+		}
+
+	      for (fd = start; fd < start + POLLFD_MAX && fd < max_fds; fd++)
+		{
+		  for (i = 0; fd_list[i].fd != -1; i++)
+		    if (fd_list[i].fd == fd)
+		      break;
+		  if (fd_list[i].fd == -1)
+		    {
+		      if (! pfd[fd - start].revents & POLLNVAL)
+			close (fd);
+		    }
+		}
+	    }
 
 	  /* And now dup and close those to be duplicated.  */
 	  for (i = 0; fd_list[i].fd != -1; i++)
@@ -526,6 +484,8 @@ _gpgme_io_spawn (const char *path, char *const argv[], unsigned int flags,
 		continue;
 
 	      res = dup2 (fd_list[i].fd, fd_list[i].dup_to);
+	      //oldflags = fcntl (fd_list[i].dup_to, F_GETFD, 0);
+	      //fcntl (fd_list[i].dup_to, F_SETFD, oldflags | FD_CLOEXEC);
 	      if (res < 0)
 		{
 #if 0
@@ -543,6 +503,8 @@ _gpgme_io_spawn (const char *path, char *const argv[], unsigned int flags,
 	  if (! seen_stdin || ! seen_stdout || !seen_stderr)
 	    {
 	      fd = open ("/dev/null", O_RDWR);
+	      oldflags = fcntl (fd, F_GETFD, 0);
+	      fcntl (fd, F_SETFD, oldflags | FD_CLOEXEC);
 	      if (fd == -1)
 		{
 		  /* The debug file descriptor is not dup'ed, so we
